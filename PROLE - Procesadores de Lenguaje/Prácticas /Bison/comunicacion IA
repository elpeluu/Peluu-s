// Analizador sintáctico de la pr3 
// Autor: Diego Garda Porto
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Declaramos yytext para acceder al nombre del identificador directamente
extern char *yytext; 
extern int yylex();
void yyerror (const char *s);

int nEtiqueta = 0;

int siguienteEtiqueta() {
    return nEtiqueta++;
}
%}

%union{
   int numero;
   char *id; 
   int eti; 
}

%token <numero>NUM <id>ID SI SINO IMPRIMIR MIENTRAS HACER SUM_ASIGN SUB_ASIGN MUL_ASIGN DIV_ASIGN ASIGN

// Definimos tipos para los no terminales que mueven etiquetas
%type <eti> if_cabecera iter_cabecera

%left '+' '-' 
%left '*' '/'

%%

list_sntncs : sntnc ';'
            | sntnc ';' list_sntncs;

sntnc : sel_stmt
      | iter_stmt
      | assig_stmt
      | print_stmt;

print_stmt : IMPRIMIR '(' expr ')'  { printf("\tprint\n"); };

// --- ESTRUCTURAS DE CONTROL (FACTORIZADAS) ---

// 1. Factorizamos la cabecera del SI para evitar conflictos Reduce/Reduce
// Esta regla maneja "si ( expr )" y genera el salto condicional.
if_cabecera : SI '(' expr ')' {
    int lbl = siguienteEtiqueta();
    printf("\tsifalsovea LBL%d\n", lbl);
    $$ = lbl; // Devolvemos la etiqueta para que la use sel_stmt
};

sel_stmt : if_cabecera '{' list_sntncs '}' {
             // Caso SI simple: Imprimimos la etiqueta al final
             printf("LBL%d\n", $1);
           }
         | if_cabecera '{' list_sntncs '}' SINO {
             // Caso SI-SINO: Parte intermedia
             int lbl_fin = siguienteEtiqueta();
             printf("\tvea LBL%d\n", lbl_fin); // Salto para saltar el SINO
             printf("LBL%d\n", $1);            // Etiqueta del SINO (donde cae si es falso el if)
             $<eti>$ = lbl_fin;                // Guardamos la etiqueta final para después
           } 
           '{' list_sntncs '}' {
             // Parte final del SINO
             printf("LBL%d\n", $<eti>6);       // Imprimimos la etiqueta de fin
           };


// 2. Factorizamos la cabecera del MIENTRAS
iter_cabecera : MIENTRAS {
    int lbl = siguienteEtiqueta();
    printf("LBL%d\n", lbl);
    $$ = lbl;
};

iter_stmt : iter_cabecera '(' expr ')' {
              int lbl_fin = siguienteEtiqueta();
              printf("\tsifalsovea LBL%d\n", lbl_fin);
              $<eti>$ = lbl_fin; // Guardamos etiqueta fin
            } 
            '{' list_sntncs '}' {
              printf("\tvea LBL%d\n", $1);      // Salto al inicio (iter_cabecera)
              printf("LBL%d\n", $<eti>5);       // Etiqueta de salida
            }
          | HACER {
              int lbl_ini = siguienteEtiqueta();
              printf("LBL%d\n", lbl_ini);
              $<eti>$ = lbl_ini;
            } 
            '{' list_sntncs '}' MIENTRAS '(' expr ')' {
              printf("\tsiciertovea LBL%d\n", $<eti>2); // Salto al inicio si cierto
            };


// --- ASIGNACIONES (USANDO yytext) ---
// Usamos yytext directamente en la acción intermedia. 
// Como la acción se ejecuta INMEDIATAMENTE tras leer el ID, yytext es válido.
// No hace falta strdup ni free.

assig_stmt : ID { printf("\tvalori %s\n", yytext); } 
             ASIGN expr { printf("\tasigna\n"); }

           | ID { 
               printf("\tvalori %s\n", yytext); 
               printf("\tvalord %s\n", yytext); 
             } 
             SUM_ASIGN expr { printf("\tsum\n"); printf("\tasigna\n"); }

           | ID { 
               printf("\tvalori %s\n", yytext); 
               printf("\tvalord %s\n", yytext); 
             } 
             SUB_ASIGN expr { printf("\tsub\n"); printf("\tasigna\n"); }

           | ID { 
               printf("\tvalori %s\n", yytext); 
               printf("\tvalord %s\n", yytext); 
             } 
             MUL_ASIGN expr { printf("\tmul\n"); printf("\tasigna\n"); }

           | ID { 
               printf("\tvalori %s\n", yytext); 
               printf("\tvalord %s\n", yytext); 
             } 
             DIV_ASIGN expr { printf("\tdiv\n"); printf("\tasigna\n"); }
           ;

// --- EXPRESIONES ---

expr : mult_expr
     | mult_expr '+' expr   {printf("\tsum\n");}       
     | mult_expr '-' expr   {printf("\tsub\n");}
     ;   
 
mult_expr : val 
     | val '*' mult_expr    {printf("\tmul\n");}        
     | val '/' mult_expr    {printf("\tdiv\n");}
     ;       

// Aquí también usamos yytext para evitar problemas con $1 no inicializado
val : NUM       {printf("\tmete %d\n", $1);}        
    | ID        {printf("\tvalord %s\n", yytext);}        
    | '(' expr ')';

%%

void yyerror(const char *s){
    fprintf(stderr, "Error de sintaxis: %s\n", s);
}

int main(){
    yyparse();
    return 0;
}
